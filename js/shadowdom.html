<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript 的工作原理：Shadow DOM 的内部结构以及如何构建可封装的组件 | zhangxinmei</title>
    <meta name="description" content="个人前端知识总结">
    <link rel="icon" href="/fe-summary/logo.png">
  <link rel="manifest" href="/fe-summary/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/fe-summary/assets/css/0.styles.8ccf35ac.css" as="style"><link rel="preload" href="/fe-summary/assets/js/app.b763d3b5.js" as="script"><link rel="preload" href="/fe-summary/assets/js/5.8516f1e9.js" as="script"><link rel="prefetch" href="/fe-summary/assets/js/10.0843d8e1.js"><link rel="prefetch" href="/fe-summary/assets/js/11.57150067.js"><link rel="prefetch" href="/fe-summary/assets/js/12.4ec4827d.js"><link rel="prefetch" href="/fe-summary/assets/js/13.3cccce74.js"><link rel="prefetch" href="/fe-summary/assets/js/14.f76b5317.js"><link rel="prefetch" href="/fe-summary/assets/js/15.7a124860.js"><link rel="prefetch" href="/fe-summary/assets/js/16.9ab3072a.js"><link rel="prefetch" href="/fe-summary/assets/js/17.9fa5310d.js"><link rel="prefetch" href="/fe-summary/assets/js/18.66932d82.js"><link rel="prefetch" href="/fe-summary/assets/js/19.2f015f60.js"><link rel="prefetch" href="/fe-summary/assets/js/2.b19e4e4a.js"><link rel="prefetch" href="/fe-summary/assets/js/20.ef9220fc.js"><link rel="prefetch" href="/fe-summary/assets/js/21.35ef7cf8.js"><link rel="prefetch" href="/fe-summary/assets/js/22.d4fe57c0.js"><link rel="prefetch" href="/fe-summary/assets/js/23.15c1084c.js"><link rel="prefetch" href="/fe-summary/assets/js/3.0cce54c4.js"><link rel="prefetch" href="/fe-summary/assets/js/4.621c9631.js"><link rel="prefetch" href="/fe-summary/assets/js/6.66435a77.js"><link rel="prefetch" href="/fe-summary/assets/js/7.05691f3f.js"><link rel="prefetch" href="/fe-summary/assets/js/8.38f470bc.js"><link rel="prefetch" href="/fe-summary/assets/js/9.48d69895.js">
    <link rel="stylesheet" href="/fe-summary/assets/css/0.styles.8ccf35ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fe-summary/" class="home-link router-link-active"><!----> <span class="site-name">zhangxinmei</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/zhangxinmei/fe-summary" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"> <a href="https://github.com/zhangxinmei/fe-summary" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>简介</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/" class="sidebar-link">简介</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>JS</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/js/javascriptType.html" class="sidebar-link">基本类型和引用类型</a></li><li><a href="/fe-summary/js/clone.html" class="sidebar-link">深拷贝和浅拷贝</a></li><li><a href="/fe-summary/js/object.html" class="sidebar-link">创建对象</a></li><li><a href="/fe-summary/js/inherit.html" class="sidebar-link">继承</a></li><li><a href="/fe-summary/js/function.html" class="sidebar-link">函数表达式</a></li><li><a href="/fe-summary/js/closure.html" class="sidebar-link">闭包</a></li><li><a href="/fe-summary/js/shadowdom.html" class="active sidebar-link">JavaScript 的工作原理：Shadow DOM 的内部结构以及如何构建可封装的组件</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/css/bfc.html" class="sidebar-link">块格式化上下文(BFC)</a></li><li><a href="/fe-summary/css/css-js-animation.html" class="sidebar-link">JavaScript 的工作原理：在 CSS 和 JS 动画的引擎下如何优化他们的表现</a></li><li><a href="/fe-summary/css/css-ellipsis.html" class="sidebar-link">文本溢出处理方案</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/vue/vue.html" class="sidebar-link">vue</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>GraphQl</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/graphql/graphql-node.html" class="sidebar-link">GraphQL 简介：原理及其使用</a></li><li><a href="/fe-summary/graphql/graphql.html" class="sidebar-link">GraphQL入门指南</a></li><li><a href="/fe-summary/graphql/graphql-shemal-design.html" class="sidebar-link">GraphQL Schema 设计：构建可演进的 Schema</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>V8</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/V8/V8.html" class="sidebar-link">极快的解析，第 1 部分：优化扫描仪</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Chrome</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/chrome/extensions.html" class="sidebar-link">如何实现一个简单的 chrome 插件</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>前端工具类</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/fe-summary/tools/terminal.html" class="sidebar-link">终端工具</a></li><li><a href="/fe-summary/tools/useful.html" class="sidebar-link">好用的工具</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="javascript-的工作原理：shadow-dom-的内部结构以及如何构建可封装的组件"><a href="#javascript-的工作原理：shadow-dom-的内部结构以及如何构建可封装的组件" aria-hidden="true" class="header-anchor">#</a> JavaScript 的工作原理：Shadow DOM 的内部结构以及如何构建可封装的组件</h1> <p><img src="/fe-summary/assets/img/shadowdom01.dfd27f50.png" alt="image"></p> <p>这是专门探索 JavaScript 及其构建组件的系列文章的第 17 篇。在识别和描述核心元素的过程中，我们还分享了构建 <a href="https://www.sessionstack.com/?utm_source=medium&utm_medium=blog&utm_content=js-series-parsing-intro" target="_blank" rel="noopener noreferrer">SessionStack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 时使用的一些经验法则，这是一个 JavaScript 应用程序，需要强大且较高性能，以帮助用户实时查看和重现他们的 Web 应用程序的缺陷。</p> <h3 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h3> <p>Web Components 是一套不同的技术，允许创你建可重用的自定义元素。它们的功能是隔离其他代码，让你可以在 Web 应用程序中使用它们。</p> <p>Web Components 有 4 个标准：</p> <ul><li>Shadow DOM</li> <li>HTML Templates</li> <li>Custom elements</li> <li>HTML Imports</li></ul> <p>在本文中，我们将重点关注 <strong>Shadow DOM</strong>。</p> <p>Shadow DOM 是被设计为用于构建基于组件的应用程序的工具，它为你能遇到的 Web 开发中的常见问题提供了解决方案：</p> <ul><li>隔离 DOM：组件的 DOM 是自包含的（例如，document.querySelector()，不会返回组件的 shadow DOM 中的节点）。这也简化了 Web 应用程序中的 CSS 选择器，因为 DOM 组件是隔离的，它使你能够使用更通用的 id 或者 class 而无需担心命名冲突。</li> <li>Scoped CSS：在 shadow DOM 中定义的 CSS 是具有作用域的，样式规则不会泄漏，页面样式不会干扰它。</li> <li>Composition：为你的组件设计一个基于标记的声明式 API。</li></ul> <h3 id="shadow-dom"><a href="#shadow-dom" aria-hidden="true" class="header-anchor">#</a> Shadow DOM</h3> <p>本文假设你已经熟悉 DOM 及其 API 的概念，如果你还不了解 DOM，你可以在这里阅读一篇关于它的详细文章——<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>除了以下两个不同之处外，Shadow DOM 只是一个普通的 DOM：</p> <ul><li>与你创建和使用 DOM 的方式相比，Shadow DOM 关注的是如何创建以及使用它与页面的其余部分的相关</li> <li>以及 Shadow DOM 与页面其余部分的关系是如何表现的</li></ul> <p>通常，你创建 DOM 节点并将它们作为子节点添加到另一个元素上。在 shadow DOM 的情况下，你创建一个添加到元素范围的 DOM 树，但它与实际的子元素分开。这个作用域的子树称为 <strong>shadow tree</strong>，它添加的元素是它的 <strong>shadow host</strong>。你添加到 shadow tree 的任何内容都将成为托管元素的本地元素，包括 <code>&lt;style&gt;</code> 标签，这就是 shadow DOM 实现 CSS scope 样式的方式。</p> <h3 id="创建-shadow-dom"><a href="#创建-shadow-dom" aria-hidden="true" class="header-anchor">#</a> 创建 Shadow DOM</h3> <p><strong>shadow root</strong> 是一个添加到 &quot;host&quot; 元素的文档片段。添加 shadow root 的那一刻并是元素获得 shadow DOM 的时刻，要为元素创建 shadow DOM，请调用 <code>element.attachShadow()</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> header <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;header&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> shadowRoot <span class="token operator">=</span> header<span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span> mode<span class="token punctuation">:</span> <span class="token string">&quot;open&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> paragraphElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

paragraphElement<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&quot;Shadow DOM&quot;</span><span class="token punctuation">;</span>
shadowRoot<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>paragraphElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><a href="http://w3c.github.io/webcomponents/spec/shadow/#h-methods" target="_blank" rel="noopener noreferrer">specification<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>定义了无法托管 <strong>shadow root</strong> 的元素列表。</p> <h3 id="shadow-dom-中的-composition"><a href="#shadow-dom-中的-composition" aria-hidden="true" class="header-anchor">#</a> Shadow DOM 中的 Composition</h3> <p>Composition 是 Shadow DOM 中最重要的特征之一。</p> <p>编写 HTML 时，Composition 是构建 Web 应用程序的方式。你可以组合并嵌套不同的元素，例如<code>&lt;div&gt;</code>，<code>&lt;header&gt;</code>，<code>&lt;form&gt;</code> 等，以构建 Web 应用程序所需的 UI，其中一些标签甚至可以互相协作。</p> <p>Composition 定义了为什么元素（如 <code>&lt;select&gt;</code>，<code>&lt;form&gt;</code>，<code>&lt;video&gt;</code>等）是灵活的，并接受特定的 HTML 元素作为子元素，以便对它们做一些特殊的事情。</p> <p>例如，<code>&lt;select&gt;</code> 知道如何将 <code>&lt;option&gt;</code> 元素渲染到具有预定义项的下拉窗口选项中。</p> <p>Shadow DOM 引入了以下可用于实现 Composition 的功能。</p> <h3 id="light-dom"><a href="#light-dom" aria-hidden="true" class="header-anchor">#</a> Light DOM</h3> <p>这是组件用户写入的标记，这个 DOM 位于组件的 shadow DOM 之外，这是元素的实际的子元素。想象一下，你已经创建了一个名为 <code>&lt;better-button&gt;</code> 的自定义组件，它扩展了原生 HTML 按钮，你想要在其中添加图像和一些文本。代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>extended<span class="token operator">-</span>button<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> the image and span are extended<span class="token operator">-</span>button's light <span class="token constant">DOM</span> <span class="token operator">--</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">&quot;boot.png&quot;</span> slot<span class="token operator">=</span><span class="token string">&quot;image&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Launch<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>extended<span class="token operator">-</span>button<span class="token operator">&gt;</span>

</code></pre></div><p>&quot;extended-button&quot; 是你定义的自定义组件，而其中的 HTML 就称为 Light DOM，是由组件的用户添加的。</p> <p>这里的 Shadow DOM 是你已经创建的组件（&quot;extended-button&quot;）。 Shadow DOM 是组件的基础，它定义了它的内部结构，作用域 CSS，并封装了你的实现细节。</p> <h3 id="扁平的-dom-树"><a href="#扁平的-dom-树" aria-hidden="true" class="header-anchor">#</a> 扁平的 DOM 树</h3> <p>浏览器将 Light DOM（由用户创建的 DOM）分配到你的 shadow DOM 中，并定义了自定义组件的结果来呈现最终产品。扁平树是你最终在 DevTools 中看到的以及页面上呈现的内容。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>extended<span class="token operator">-</span>button<span class="token operator">&gt;</span>
  #shadow<span class="token operator">-</span>root
  <span class="token operator">&lt;</span>style<span class="token operator">&gt;</span>…<span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>slot name<span class="token operator">=</span><span class="token string">&quot;image&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">&quot;boot.png&quot;</span> slot<span class="token operator">=</span><span class="token string">&quot;image&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>slot<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Launch<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>extended<span class="token operator">-</span>button<span class="token operator">&gt;</span>
</code></pre></div><h3 id="模板（template）"><a href="#模板（template）" aria-hidden="true" class="header-anchor">#</a> 模板（template）</h3> <p>当你必须在网页上重复使用相同的标记结构时，最好使用某种模板而不是一遍又一遍地重复相同的结构。在之前这是可能的，HTML 中的<code>&lt;template&gt;</code> 元素（在现代浏览器中得到了很好的支持）使它变得更加容易。此元素及其内容不会在 DOM 中呈现，但仍可使用 JavaScript 来引用它。</p> <p>让我们看一个简单的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template id<span class="token operator">=</span><span class="token string">&quot;my-paragraph&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span> Paragraph content<span class="token punctuation">.</span> <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre></div><p>在你使用 JavaScript 引用它之前，它不会出现在你的页面中，然后使用以下方法将其添加到 DOM：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> template <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;my-paragraph&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> templateContent <span class="token operator">=</span> template<span class="token punctuation">.</span>content<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>templateContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>到目前为止，已经有其他技术可以实现类似的行为，但是，如前所述，将其本身包含在内是非常好的。并且 template 也有相当不错的浏览器支持：</p> <p><img src="images/shadowdom03.png" alt="shadowdom02"></p> <p>template 本身很有用，但它使用自定义元素可以更好地工作。我们将在本系列的另一篇文章中讲述自定义元素，暂时你应该知道浏览器中的<code>customElement</code> API 允许你使用自定义渲染定义自己的标记。</p> <p>让我们定义一个 Web 组件，它使用我们的模板作为其 shadow DOM 的内容，我们称之为 <code>&lt;my-paragraph&gt;</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span>
  <span class="token string">&quot;my-paragraph&quot;</span><span class="token punctuation">,</span>
  <span class="token keyword">class</span> <span class="token class-name">extends</span> HTMLElement <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">let</span> template <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;my-paragraph&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> templateContent <span class="token operator">=</span> template<span class="token punctuation">.</span>content<span class="token punctuation">;</span>
      <span class="token keyword">const</span> shadowRoot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span> mode<span class="token punctuation">:</span> <span class="token string">&quot;open&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>
        templateContent<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里要注意的关键点是我们将模板内容克隆添加到 shadow root，它是使用 <code>Node.cloneNode()</code> 方法创建的。</p> <p>因为我们将其内容添加到 shadow DOM 中，所以可以在模板中的 <code>&lt;style&gt;</code> 元素中包含一些样式信息，然后将其封装在自定义元素中。如果只是将它添加到标准 DOM 中，这将不起作用。</p> <p>例如，可以将模板更改为以下内容：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>my-paragraph<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
    <span class="token selector">p</span> <span class="token punctuation">{</span>
      <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>
      <span class="token property">background-color</span><span class="token punctuation">:</span> #666<span class="token punctuation">;</span>
      <span class="token property">padding</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Paragraph content. <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><p>现在，我们可以像这样使用模板定义的自定义组件：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-paragraph</span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><h3 id="slots（插槽）"><a href="#slots（插槽）" aria-hidden="true" class="header-anchor">#</a> Slots（插槽）</h3> <p>Template 有一些缺点：主要是静态内容，它不允许渲染我们的变量或者数据，以使其按照你习惯使用的标准 HTML 模板的方式工作。</p> <p>这就是 <code>&lt;slot&gt;</code> 出现的原因。你可以将插槽视为占位符，允许你将自己的 HTML 放在模板中，这允许你创建通用的 HTML 模板，然后通过添加插槽使其可自定义。</p> <p>让我们看看上面所说的模板与插槽结合的代码是什么样的：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>my-paragraph<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>my-text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Default text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如果在元素包含在标记中时未定义插槽的内容，或者如果浏览器不支持插槽，则 <code>&lt;my-paragraph&gt;</code> 将仅包含“默认文本”。</p> <p>要定义插槽的内容，我们应该在 <code>&lt;my-paragraph&gt;</code> 元素中包含一个 HTML 结构，其中 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-slot" target="_blank" rel="noopener noreferrer">slot<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 属性的值等于我们希望它填充的插槽的名称。</p> <p>和以前一样，你可以添加你喜欢的任何内容：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-paragraph</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>my-text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Let's have some different text!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-paragraph</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>可以插入插槽的元素称为 Slotable，当一个元素插入一个插槽时，它被称为 slotted。</p> <p>请注意，在上面的示例中，我们插入了一个 <code>&lt;span&gt;</code> 元素，它是一个开槽元素。它有一个属性 <code>slot</code>，它的值为 &quot;my-text&quot;，它与模板槽定义中 <code>name</code> 属性的值相同。</p> <p>在浏览器中呈现后，上面的代码将创建以下扁平 DOM 树：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-paragraph</span><span class="token punctuation">&gt;</span></span>
  #shadow-root
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>my-text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>my-text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Let's have some different text!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-paragraph</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>注意 <code>＃shadow-root</code> 元素——它只是 Shadow DOM 存在的指示符。</p> <h3 id="样式"><a href="#样式" aria-hidden="true" class="header-anchor">#</a> 样式</h3> <p>使用 shadow DOM 的组件可以由主页面设置样式，可以定义自己的样式，或者以 CSS 自定义属性的形式提供钩子，以便用户覆盖默认样式。</p> <h3 id="组件定义的样式"><a href="#组件定义的样式" aria-hidden="true" class="header-anchor">#</a> 组件定义的样式</h3> <p>Scoped CSS 是 Shadow DOM 的最大特色之一：</p> <ul><li>外部页面中的 CSS 选择器不适用于组件内部。</li> <li>组件内定义的样式不会影响页面的其余部分，它们作用的范围是宿主素。</li></ul> <p>Shadow DOM 中使用的 CSS 选择器应用于组件。实际上，这意味着我们可以再次使用常见的 id 或者 class 名称，而不必担心页面上其他地方的冲突，简单的 CSS 选择器意味着更好的性能。</p> <p>让我们看一下定义了一些样式的 <code>＃shadow-root</code>：</p> <div class="language-html extra-class"><pre class="language-html"><code>#shadow-root
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
  <span class="token selector">#container</span> <span class="token punctuation">{</span>
    <span class="token property">background</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">#container-items</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> inline-flex<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>container-items<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面示例中的所有样式都是 <code>＃shadow-root</code> 的本地样式，你还可以使用 <code>&lt;link&gt;</code> 元素在 <code>＃shadow-root</code> 中包含样式表，这些样式表也是本地的。</p> <h3 id="host-伪类"><a href="#host-伪类" aria-hidden="true" class="header-anchor">#</a> :host 伪类</h3> <p>:host 允许你选择并设置 shadow tree 的元素的样式：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
  <span class="token selector">:host</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span> <span class="token comment">/* by default, custom elements are display: inline */</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在涉及到以下内容时，你应该注意 <code>:host</code> ——父页面中的规则具有比 :host 规则中定义的内容更高的优先级。这允许用户从外部覆盖你的顶级样式。此外，<code>:host</code> 仅在 shadow root 的上下文中工作，因此你不能在 Shadow DOM 之外使用它。</p> <p>函数形式 <code>:host(&lt;selector&gt;)</code> 允许你在与 <code>&lt;selector&gt;</code> 匹配时定位 host 伪类。这是组件封装响应用户交互或状态的行为以及基于 host 伪类设置内部节点样式的好方法：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
  <span class="token selector">:host</span> <span class="token punctuation">{</span>
    <span class="token property">opacity</span><span class="token punctuation">:</span> 0.4<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token selector">:host(:hover)</span> <span class="token punctuation">{</span>
    <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token selector">:host([disabled])</span> <span class="token punctuation">{</span> <span class="token comment">/* style when host has disabled attribute. */</span>
    <span class="token property">background</span><span class="token punctuation">:</span> grey<span class="token punctuation">;</span>
    <span class="token property">pointer-events</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
    <span class="token property">opacity</span><span class="token punctuation">:</span> 0.4<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token selector">:host(.pink) &gt; #tabs</span> <span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span> <span class="token comment">/* color internal #tabs node when host has class=&quot;pink&quot;. */</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="主题和元素-host-context-伪类"><a href="#主题和元素-host-context-伪类" aria-hidden="true" class="header-anchor">#</a> 主题和元素:host-context(<selector>) 伪类</selector></h3> <p><code>:host-context(&lt;selector&gt;)</code> 伪类与 宿主元素匹配（如果后者或其任何祖先与 <code>&lt;selector&gt;</code> 匹配）。</p> <p>对此的常见用途是主题，例如，许多人通过将类应用于 <code>&lt;html&gt;</code> 或 <code>&lt;body&gt;</code> 来进行主题化：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>lightheme<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-container</span><span class="token punctuation">&gt;</span></span>…<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-container</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>:host-context(.lightheme)</code> 在类是 <code>.lightheme</code> 的后代元素时会设置 <code>&lt;fancy-tabs&gt;</code> 的样式：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">:host-context(.lightheme)</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>:host-context()</code> 可以用于主题，但更好的方法是使用 <a href="https://developers.google.com/web/fundamentals/web-components/shadowdom#stylehooks" target="_blank" rel="noopener noreferrer">CSS 自定义属性创建样式钩子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h3 id="从外部设置组件的宿主元素的样式"><a href="#从外部设置组件的宿主元素的样式" aria-hidden="true" class="header-anchor">#</a> 从外部设置组件的宿主元素的样式</h3> <p>你可以通过使用它们的标记名称作为选择器从外部设置组件的宿主元素，如下所示：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">custom-container</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="外部样式的优先级高于-shadow-dom-中定义的样式。"><a href="#外部样式的优先级高于-shadow-dom-中定义的样式。" aria-hidden="true" class="header-anchor">#</a> 外部样式的优先级高于 Shadow DOM 中定义的样式。</h4> <p>例如，如果用户编写选择器：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">custom-container</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它将覆盖组件的规则：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">:host</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>样式化组件本身只能让你实现到现在这样，但是如果要为组件的内部构造样式会发生什么呢？为此，我们需要 CSS 自定义属性。</p> <h3 id="使用-css-自定义属性创建-style-hooks"><a href="#使用-css-自定义属性创建-style-hooks" aria-hidden="true" class="header-anchor">#</a> 使用 CSS 自定义属性创建 style hooks</h3> <p>如果组件的作者使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener noreferrer">CSS custom properties<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供的样式钩子，则用户可以调整内部样式。</p> <p>这个想法与 <code>&lt;slot&gt;</code> 类似，但适用于样式。
我们来看看下面的例子：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- main page --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
  <span class="token selector">custom-container</span> <span class="token punctuation">{</span>
    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 60px<span class="token punctuation">;</span>
     <span class="token property">- custom-container-bg</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-container</span> <span class="token attr-name">background</span><span class="token punctuation">&gt;</span></span>…<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-container</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在 Shadow DOM 中：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">:host([background])</span> <span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span> - custom-container-bg, #cecece<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这种情况下，组件将使用黑色作为背景值，因为用户提供了它。否则，它将默认为#CECECE。作为组件作者，你负责让开发人员了解他们可以使用的 CSS 自定义属性并将其视为组件公共接口的一部分。</p> <h3 id="插槽-api"><a href="#插槽-api" aria-hidden="true" class="header-anchor">#</a> 插槽 API</h3> <p>Shadow DOM API 提供了使用插槽的实用程序。</p> <h3 id="slotchange-事件"><a href="#slotchange-事件" aria-hidden="true" class="header-anchor">#</a> slotchange 事件</h3> <p>当插槽的分布式节点发生更改时，会切换 slotchange 事件。例如，如果用户从 Light DOM 添加或删除子项。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> slot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>shadowRoot<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#some_slot&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
slot<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;slotchange&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Light DOM change&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>要监听 light DOM 的其他类型的更改，可以在元素的构造函数中使用 <code>MutationObserver</code>。我们之前已经讨论过 <a href="https://blog.sessionstack.com/how-javascript-works-tracking-changes-in-the-dom-using-mutationobserver-86adc7446401" target="_blank" rel="noopener noreferrer">MutationObserver 的内部以及如何使用它<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h3 id="assignednodes-方法"><a href="#assignednodes-方法" aria-hidden="true" class="header-anchor">#</a> assignedNodes() 方法</h3> <p>知道哪些元素与插槽相关联可能很有用，调用 <code>slot.assignedNodes()</code> 方法，可以为你提供插槽所呈现的元素。 <code>{flatten: true}</code> 选项还将返回插槽的后备内容（如果没有分发节点）。</p> <p>我们来看下面的例子：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>slot1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Default content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>我们假设这是一个名为 <code>&lt;my-container&gt;</code> 的组件，让我们来看看这个组件的不同用法以及调 <code>assignedNodes()</code> 的结果：</p> <p>在第一种情况下，将我们自己的内容添加到插槽中：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-container</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>slot1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> container text <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-container</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>调用 <code>assignedNodes()</code> 将返回 <code>[&lt;span slot =&quot;slot1&quot;&gt; container text &lt;/span&gt;]</code>，请注意，结果是一个节点数组。</p> <p>在第二种情况下，我们将内容留空：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-container</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-container</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>调用 <code>assignedNodes()</code> 的结果将返回一个空数组[]。</p> <p>但是，如果你为同一元素传递 <code>{flatten: true}</code> 参数，则会得到默认内容：<code>[&lt;p&gt;Default content&lt;/p&gt;]</code>。</p> <p>此外，要访问插槽内的元素，可以调用 <code>assignedNodes()</code> 以查看元素分配给了哪个组件的插槽。</p> <h3 id="事件模型"><a href="#事件模型" aria-hidden="true" class="header-anchor">#</a> 事件模型</h3> <p>有趣的是要注意当 Shadow DOM 中发生事件冒泡时会发生什么。调整事件的目标以维持 Shadow DOM 提供的封装。当事件被重新定位时，它看起来像是来自组件本身，而不是作为组件一部分的 Shadow DOM 中的内部元素。</p> <p>以下是从 Shadow DOM 中包含的事件列表（有些事件没有）：</p> <ul><li><strong>焦点 事件</strong>：blur, focus, focusin, focusout</li> <li><strong>鼠标事件</strong>：click, dblclick, mousedown, mouseenter, mousemove 等</li> <li><strong>Wheel 事件</strong>：wheel</li> <li><strong>Input 事件</strong>：beforeinput, input</li> <li><strong>键盘事件</strong>：keydown,keyup</li> <li><strong>Composition 事件</strong>：compositionstart, compositionupdate, compositionend</li> <li><strong>拖拽事件</strong>： dragstart, drag, dragend, drop 等</li></ul> <h3 id="自定义事件"><a href="#自定义事件" aria-hidden="true" class="header-anchor">#</a> 自定义事件</h3> <p>默认情况下，自定义事件不会传递到 Shadow DOM 之外。如果想要分发自定义事件并希望它传递，则需要添加 <code>bubbles: true</code> 和 <code>composition: true</code> 作为选项。</p> <p>让我们看看如何分发这样的事件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> container <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>shadowRoot<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#container&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
container<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">&quot;containerchanged&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> bubbles<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> composed<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>浏览器支持情况：</p> <p>要检测 Shadow DOM 是否是受浏览器支持的，请检查是否存在 attachShadow：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> supportsShadowDOMV1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>HTMLElement<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>attachShadow<span class="token punctuation">;</span>
</code></pre></div><p><img src="/fe-summary/assets/img/shadowdom02.41c148fb.png" alt="image"></p> <p>通常，Shadow DOM 的行为方式与 DOM 是完全不同的。我们从 SessionStack 库的经验中得到了第一手的例子。我们将库集成到 Web 应用程序中以收集用户事件，网络数据，异常，调试消息，DOM 更改等数据，并将此数据发送到我们的服务器。</p> <p>之后，我们处理收集的数据，以便你使用 SessionStack 重现产品中发生的问题。</p> <p>使用 Shadow DOM 产生的困难如下：我们必须监听每个 DOM 的更改，以便以后能够正确地重新放置它。我们通过使用 <code>MutationObserver</code> 来做到这一点。但是，Shadow DOM 不会在全局范围内触发 <code>MutationObserver</code> 事件，这意味着我们需要以不同方式处理这些组件。</p> <p>如果你想试试 <a href="https://www.sessionstack.com/solutions/developers/?utm_source=medium&utm_medium=blog&utm_content=shadow-dom" target="_blank" rel="noopener noreferrer">SessionStack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，有一个免费的平台。</p> <p><img src="/fe-summary/assets/img/shadowdom04.92245513.png" alt="image"></p> <p>参考：</p> <ul><li>(https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM)[https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM]</li> <li>(https://developers.google.com/web/fundamentals/web-components/shadowdom)[https://developers.google.com/web/fundamentals/web-components/shadowdom]</li> <li>(https://developers.google.com/web/fundamentals/web-components/shadowdom)[https://developers.google.com/web/fundamentals/web-components/shadowdom]</li> <li>(https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-style-host)[https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-style-host]</li></ul> <p>原文链接：<a href="https://blog.sessionstack.com/how-javascript-works-the-internals-of-shadow-dom-how-to-build-self-contained-components-244331c4de6e" target="_blank" rel="noopener noreferrer">https://blog.sessionstack.com/how-javascript-works-the-internals-of-shadow-dom-how-to-build-self-contained-components-244331c4de6e<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/zhangxinmei/fe-summary/edit/master/docs/js/shadowdom.md" target="_blank" rel="noopener noreferrer">编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2019/6/26 21:43:44</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/fe-summary/js/closure.html" class="prev">
          闭包
        </a></span> <span class="next"><a href="/fe-summary/css/bfc.html">
          块格式化上下文(BFC)
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/fe-summary/assets/js/app.b763d3b5.js" defer></script><script src="/fe-summary/assets/js/5.8516f1e9.js" defer></script>
  </body>
</html>
